/**
 * ボイス再生用トラック
 */
class VoiceTrack extends WaveSoundBuffer
{
	var owner, kag;
	var labelCount;

	function VoiceTrack(owner, kag) {
		this.owner = owner;
		this.kag   = (kag !== void) ? kag : global.kag;
		labelCount = 0;
		super.WaveSoundBuffer(owner);
		prevstatus = status; //"unload";
	}

	function onStartVoice() { owner.onStartVoice(); }
	function onStopVoice()  { owner.onStopVoice();  }

	function play() {
		onStartVoice();
		super.play(...);
		var names = [];
		names.assign(labels);
		// ↑WaveSoundBuffer.labels は特殊な EnumMembers が実装されており，
		//   必ずsamplePositionでソートされた状態assignされる（Dictionaryのように順序不定にならない）
		var n = 0;
		var entryDelay = kag.entryDelay; // [NGK]
		for (var i=0;i<names.count;i+=2) {
			entryDelay(names[i]);
			entryDelay("vl" + ++n);
		}
		labelCount = 0;
	}

	var prevstatus; // 直前のステータス
	function onStatusChanged() {
		super.onStatusChanged(...);
		var ps = prevstatus;
		var cs = prevstatus = status;
		onStopVoice() if(ps == "play" && cs == "stop");
    }

	function onLabel(name) {
		var extractDelay = kag.extractDelay; // [NGK]
		extractDelay(name);
		extractDelay("vl" + ++labelCount);
	}
};

/**
 * ループボイス再生用トラック
 */
class BackVoiceTrack extends VoiceTrack
{
	function BackVoiceTrack() {
		super.VoiceTrack(...);
	}

	function onStartVoice() {}
	function onStopVoice()  {}

	function onFadeCompleted() {
		stop() if (volume == 0);
	}
};

/**
 * キャラクタ用座標補正対応レイヤ
 */
class EmotionLayer extends EnvGraphicLayer {

	/**
	 * コンストラクタ
	 */
	function EmotionLayer(win, par, owner) {
		// 親コンストラクタ
		super.EnvGraphicLayer(win, par, owner);
	}

	/**
	 * オフセット情報の初期化
	 */
	function updateOffsetInfo() {
		// 基準サイズ
		var basezoom = owner.env.envinfo.emoZoom;
		if (basezoom === void) {
			basezoom = 100;
		}
		if (owner !== void) {
			var init = owner.init;
			var basexoff = init.xoffset !== void ? +init.xoffset : +ownerenv.xoffset;
			var baseyoff = init.yoffset !== void ? +init.yoffset : +ownerenv.yoffset;
			if (owner.levels !== void) {
				// 強制全レベルオフセット指定モード
				var levelInfo = owner.levels[owner.level];
				xoffset = (int)(levelInfo !== void ? levelInfo.xoffset : 0) + basexoff;
				yoffset = (int)(levelInfo !== void ? levelInfo.yoffset : 0) + baseyoff;
				zoom = levelInfo !== void && levelInfo.zoom !== void ? levelInfo.zoom : 100;
			} else {
				// env 定義によるレベル補正
				xoffset = (int)(owner.xoffset !== void ? +owner.xoffset : 0) + basexoff;
				yoffset = (int)(owner.yoffset !== void ? +owner.yoffset : 0) + baseyoff;
				var levelInfo = ownerenv.levels[owner.level];
				if (levelInfo !== void) {
					levelz       = levelInfo.zoom !== void ? (int)levelInfo.zoom : 100;
					levelxoffset = levelInfo.xoffset !== void ? (int)levelInfo.xoffset : 0;
					levelyoffset = levelInfo.yoffset !== void ? (int)levelInfo.yoffset : 0;
				}
				zoom = levelInfo !== void && levelInfo.zoom !== void ? levelInfo.zoom : 100;
			}
			//dm("リセット処理 level:" + owner.level);
			//dm("owner offset:" + owner.xoffset + "," + owner.yoffset);
			//dm("offset:" + xoffset + "," + yoffset);
			//dm("levelz:" + levelz);
			zoom = zoom / basezoom * 100;
		}
	}
};


/**
 * キャラクタ用座標補正対応レイヤ
 */
class EnvCharacterGraphicLayer extends EnvGraphicLayer {

	/**
	 * コンストラクタ
	 */
	function EnvCharacterGraphicLayer(win, par, owner) {
		// 親コンストラクタ
		super.EnvGraphicLayer(win, par, owner);
	}

	/**
	 * オフセット情報の初期化
	 */
	function updateOffsetInfo() {
		if (owner !== void) {
			var init = owner.init;
			var basexoff = init.xoffset !== void ? +init.xoffset : +ownerenv.xoffset;
			var baseyoff = init.yoffset !== void ? +init.yoffset : +ownerenv.yoffset;
			if (owner.levels !== void) {
				// 強制全レベルオフセット指定モード
				var levelInfo = owner.levels[owner.level];
				xoffset = (int)(levelInfo !== void ? levelInfo.xoffset : 0) + basexoff;
				yoffset = (int)(levelInfo !== void ? levelInfo.yoffset : 0) + baseyoff;
			} else {
				// env 定義によるレベル補正
				xoffset = (int)(owner.xoffset !== void ? +owner.xoffset : 0) + basexoff;
				yoffset = (int)(owner.yoffset !== void ? +owner.yoffset : 0) + baseyoff;
				var levelInfo = ownerenv.levels[owner.level];
				if (levelInfo !== void) {
					levelz       = levelInfo.zoom !== void ? (int)levelInfo.zoom : 100;
					levelxoffset = levelInfo.xoffset !== void ? (int)levelInfo.xoffset : 0;
					levelyoffset = levelInfo.yoffset !== void ? (int)levelInfo.yoffset : 0;
				}
			}
			//dm("リセット処理 level:" + owner.level);
			//dm("owner offset:" + owner.xoffset + "," + owner.yoffset);
			//dm("offset:" + xoffset + "," + yoffset);
			//dm("levelz:" + levelz);
		}
	}
};


/**
 * キャラクタレイヤ
 * ポーズの指定他
 */
class KAGEnvCharacter extends KAGEnvImage, KAGEnvLevelLayer {

    // kag の参照
    property kag {
        getter() {
            return window; // KAGEnvImage.window == env.kag;
        }
    }

    // フェード指定のデフォルト
    property fadeValue {
        getter() {
			if (init !== void && init.fadeValue !== void) {
				return init.fadeValue;
			} else {
                if (env.envinfo !== void && env.envinfo.charFadeValue !== void) {
					return env.envinfo.charFadeValue;
				} else {
					return env.fadeValue;
				}
			}
        }
    }

	/**
	 * 表示処理用の自動トランジションの指定
	 */
	function setDispAutoTrans(elm) {
		setAutoTrans([init.dispTrans, env.envinfo.charDispTrans], elm);
	}
	
	/// 初期化名
    var initName;
	/// 立ち絵名
	var standName;

    /// 初期化情報
    var poses;

    // 画像ファイル直接指定
    var image;
	// ポーズ個別オフセット補正
	var yoffset;
	var xoffset;
	var levels;
    
    /// ポーズ
	var pose;
    /// 服装
    var dress;
    /// 表情
    var face;

    var facePoseMap;
    
    /// ボイス情報
    var voice;
    var strVoice;
    var incVoice;   // true なら文字列指定時もカウントする
    var noincVoice; // true ならカウントしない
    
    // ベース画像名
    var baseImageName;
    // ベース画像
    var baseImage;
    // 顔画像
    var faceImage;

    // エモーション
	var emotion;
	var hideemo;
    var emotionLayer;

    /**
     * コンストラクタ
     * @param env 環境オブジェクト
     * @param name キャラクタ名
     * @param init キャラクタ初期化データ
     */
	function KAGEnvCharacter(env, name, initName, init) {

		defaultAfy = "bottom";
		global.KAGEnvImage.KAGEnvImage(env, name);
		global.KAGEnvLevelLayer.KAGEnvLevelLayer();

		layerClass = global.EnvCharacterGraphicLayer;
        
		//dm("キャラクタ登録:" + name); 
		this.initName = initName;
		this.init     = init;
		this.standName = init.standName !== void ? init.standName : initName;
        if (init) {
			poses = init.poses; //showKeys("poses", poses);
			if (poses !== void && init.defaultPose !== void) {
				_setPose(init.defaultPose);
			}
            // 表情ポーズ同期機能
            if (init.facePose) {
                // 表情からポーズに対するマップを作成する
                facePoseMap = %[];
				foreach(poses, function(name, value, dict, facePoseMap) {
                    var faces = [];
                    faces.assign(value.faces);
                    for (var i=0; i<faces.count; i+= 2) {
                        facePoseMap[faces[i]] = name;
                    }
                }, facePoseMap);
            }

		}

		if (env.envinfo.voiceInit !== void && init.voiceFile !== void) {
			voice = env.envinfo.voiceInit;
		}
    }

	function clearStandLayers() {
	}

	function finalize() {
		clearStandLayers();
		if (baseImage !== void) {
            invalidate baseImage;
        }
        if (faceImage !== void) {
            invalidate faceImage;
        }
        if (soundBuffer !== void) {
            invalidate soundBuffer;
		}
		if (backVoiceBuffer !== void) {
			invalidate backVoiceBuffer;
		}
		if (emotionLayer !== void) {
			invalidate emotionLayer;
		}
		// 順番変更不可注意
		global.KAGEnvLevelLayer.finalize();
		global.KAGEnvImage.finalize();
    }

    /**
     * セーブ処理
     */
	function onStore(f) {
        global.KAGEnvImage.onStore(f);
		global.KAGEnvLevelLayer.onStore(f);
        f.initName = initName;
        f.image = image;
        f.yoffset = yoffset;
		f.xoffset = xoffset;
		f.levels = levels;
		f.pose = pose;
		f.dress = dress;
        f.face = face;
        f.voice = voice;
        f.strVoice = strVoice;
		f.posName = posName;
		f.backVoiceName = backVoiceName;
		f.backVoiceLoop = backVoiceLoop;
    }

    /**
     * ロード処理
     */
    function onRestore(f) {
        image = f.image;
        yoffset = f.yoffset;
		xoffset = f.xoffset;
		levels = f.levels;
		pose  = f.pose;
        dress = f.dress;
        face  = f.face;
        voice = f.voice;
        strVoice = f.strVoice;
		posName  = posName;
		backVoiceName = f.backVoiceName;
		backVoiceLoop = f.backVoiceLoop;
		global.KAGEnvImage.onRestore(f);
		global.KAGEnvLevelLayer.onRestore(f);
    }

    // 表情描画処理を行う
    var redrawFace;

	function setRedrawFace(elm) {
		if (!kag.skipNoDisp && isShowFace() && (elm.faceon || env.showFaceMode || env.currentNameTarget === this) && !elm.faceoff) {
			redrawFace = true;
		}
	}
	
    /**
     * 直接画像指定
     */
    function setImage(imageName, elm) {
		if (imageName != image || isClear()) {
			image   = imageName;
			yoffset = elm.yoffset;
			xoffset = elm.xoffset;
			disp = SHOW;
			redraw  = true;
			setAutoTrans([init.poseTrans, init.charTrans, env.envinfo.poseTrans, env.envinfo.charTrans], elm);
		}
    }

	function _setPose(poseName) {
		var info = poses[poseName];
		if (info !== void) {
			pose = poseName;
			yoffset = info.yoffset;
			xoffset = info.xoffset;
			levels  = info.levels !== void ? info.levels : init.levels;
		}
	}
	
    /**
     * ポーズの設定
     */
    function setPose(poseName, elm) {
		if (poses !== void) {
			var info = poses[poseName];
			if (info !== void) {
				if (poseName != pose || isClear()) {
					// ポーズ変更時はエモーション消去
					if (elm.emotion === void) {
						hideEmotion();
					}
					initFile(elm);
					_setPose(poseName);
					//dm(poseName + ":レベル設定:" + levels);
					disp = SHOW;
					redraw = true;
					setAutoTrans([info.trans, init.poseTrans, init.charTrans, env.envinfo.poseTrans, env.envinfo.charTrans], elm);
					
					// 表情表示取得
					setRedrawFace(elm);
				}
				// 服装初期化処理
				if (dress !== void && (info.dresses == void || info.dresses[dress] == void)) {
					dress = void;
				}
				// 表情初期化処理
				if (face !== void && (info.faces == void || info.faces[face] == void)) {
					face = void;
				}
			}
		}
		// イメージを破棄
		image = void;
		// ypos はポーズ設定したときに0に戻す
		ypos = 0;
	}

    /**
     * 服装の設定
     */
    function setDress(dressName, elm) {
		if (dressName != dress || isClear()) {
			// 服装変更時はエモーション消去
			if (elm.emotion === void) {
				hideEmotion();
			}
			initFile(elm);
			dress = dressName;
			disp = SHOW;
			redraw = true;
			setAutoTrans([init.dressTrans, init.charTrans, env.envinfo.dressTrans, env.envinfo.charTrans], elm);
			// 表情表示取得
			setRedrawFace(elm);
		}
		image = void;
    }
    /**
     * 表情の設定
      */
    function setFace(faceName, elm) {
		if (faceName != face || isClear()) {
			face = faceName;
			disp = SHOW;
			redraw = true;
			setAutoTrans([init.faceTrans, init.charTrans, env.envinfo.faceTrans, env.envinfo.charTrans], elm);
			// 表情表示取得
			setRedrawFace(elm);
		}
		image = void;
    }

	// 表示位置指定
	var posName;

	var  posCollisionCheckEnabled = global.debugWindowEnabled;
	var _posCollisionCheck;
	function resetPosCollision() {
		if (_posCollisionCheck === void) {
			_posCollisionCheck = %[ xpos:[], ypos:[], level:[]/*, disp:[]*/ ];
		} else with (_posCollisionCheck) {
			.xpos .clear();
			.ypos .clear();
			.level.clear();
//			.disp .clear();
		}
	}
	function setPosCollision(elm, cmd, tag) {
		_posCollisionCheck[tag].add(cmd !== void ? cmd : tag) if (elm[tag] !== void);
	}
	function errorPosCollision(tag) {
		if (tag === void) {
			errorPosCollision("xpos");
			errorPosCollision("ypos");
			errorPosCollision("level");
//			errorPosCollision("disp");
		} else if (_posCollisionCheck[tag].count > 1) {
			kag.errorCmd(@"${name}: ${tag}が多重指定されています: " + _posCollisionCheck[tag].join("/"));
		}
	}
	function checkPosCollision(elm, cmd) {
		if (posCollisionCheckEnabled) {
			setPosCollision(elm, cmd, "xpos");
			setPosCollision(elm, cmd, "ypos");
			setPosCollision(elm, cmd, "level");
//			setPosCollision(elm, cmd, "disp");
		}
	}
	function onBeforeDoCommand(elm) {
		if (posCollisionCheckEnabled) {
			resetPosCollision();
			checkPosCollision(elm);
		}
	}
	function  onAfterDoCommand(elm) {
		if (posCollisionCheckEnabled) errorPosCollision();
	}

    /**
     * 表示位置の設定
     */
    function setPosition(cmd, elm) {

		var istrans = false;
		
		posName = getTo(cmd);
		var info;
        if (env.positions === void || (info = env.positions[posName]) === void) {
            return;
        }

		checkPosCollision(info, cmd);

		if (info.xpos !== void || info.ypos !== void) {
			if (disp == CLEAR) {
				disp = SHOW;
			}
			var posFrom = getFrom(cmd);
            var fromInfo;
			if (posFrom !== void && (fromInfo = env.positions[posFrom]) !== void) {
				moveTime = info.time !== void ? info.time : elm.time;
				moveAccel = (elm.accel === void) ? 0 : elm.accel;
				if (fromInfo.xpos !== void) {
					xposFrom   = calcRelative(xpos, fromInfo.xpos, env.xmax);
				}
				if (info.xpos !== void) {
					xpos       = calcRelative(xpos, info.xpos, env.xmax);
				}					
				if (fromInfo.ypos !== void) {
					yposFrom   = calcRelative(ypos, fromInfo.ypos, env.ymax);
				}
				if (info.ypos !== void) {
					ypos       = calcRelative(ypos, info.ypos, env.ymax);
				}
				reposition = true;
			} else {
				var newxpos = info.xpos !== void ? calcRelative(xpos, info.xpos, env.xmax) : xpos;
				var newypos = info.ypos !== void ? calcRelative(xpos, info.ypos, env.ymax) : ypos;
				if (xpos == void || xpos != newxpos || ypos == void || ypos != newypos) {
					moveTime = info.time !== void ? info.time : elm.time;
					if (moveTime !== void && xpos === void) {
						moveTime = 0;
					}
					moveAccel = (elm.accel === void) ? 0 : elm.accel;
					xpos = newxpos;
					ypos = newypos;
					reposition = true;
					if (moveTime === void) {
						redraw = true;
						istrans = true;
					}
				}
			}
			if (moveTime !== void && isSkip()) {
				moveTime = 0;
			}
		}

		if (info.disp !== void) {
			if (info.ypos === void && elm.ypos === void && disp == CLEAR && info.disp < BU) {
				// 表示時はY位置リセットと状態初期化
				initFile(elm);
				ypos = 0;
			}
			disp = info.disp;
			redraw = true;
			istrans = true;
		}

		if (info.level !== void) {
			level = info.level;
			if (elm.back !== void) toBack(); // [XXX] 評価順が不定のため：レベル変更時には常に手前なのでfrontは不要
			if (elm.hide === void && disp == CLEAR) {
				if (info.ypos === void && elm.ypos === void) { // 表示時はY位置リセットと状態初期化
					initFile(elm);
					ypos = 0;
				}
				disp = SHOW;
			}
			istrans = true;
		}

		if (info.trans !== void) {
			setAutoTrans([info.trans], elm);
		} else if (istrans) {
			setAutoTrans([env.envinfo.positionTrans], elm);
		}
	}

    /**
     * エモーションの設定
     */
	function setEmotion(name, elm) {
		var info;
		// エモーション名ポーズ別置換処理
		if (env.emotionmap !== void) {
			var emoPose = pose.replace(/（.*）|\(.*\)/, "");
			var emoMapName = standName + "_" + emoPose + "_" + name;
			var emoName = env.emotionmap[emoMapName];
			if (emoName !== void) {
				name = emoName;
			}
			//dm("エモーション名:" + emoMapName + ":" + name);
		}
		if (!elm.hideemotion && env.emotions !== void && (info = env.emotions[name]) !== void) {
			hideemo = void;
			emotion = %[];
			(Dictionary.assign incontextof emotion)(info, false);
			if (emotion.name === void) {
				emotion.name = name;
			}
			emotion.time   = elm.time if elm.time !== void;
			emotion.nowait = elm.nowait if elm.nowqait !== void;
			emotion.hide   = elm.hide if elm.hide !== void;
			updateFlag = true;
			return true;
		}
		return false;
    }

    /**
     * エモーションの解除
     */
	function hideEmotion(param, elm) {
		if (emotionLayer !== void && emotionLayer.visible) {
			if (param === void) {
				hideemo = env.envinfo.emoHideTime !== void ? +env.envinfo.emoHideTime : 500;
			} else if (param == "true") {
				hideemo = elm.time !== void ? +elm.time : env.envinfo.emoHideTime !== void ? +env.envinfo.emoHideTime : 500;
			} else {
				hideemo = +param;
			}
			updateFlag = true;
		}
		return 0;
	}

	
    var charCommands = %[
    image   : this.setImage incontextof this,
    dress   : this.setDress incontextof this,
    face    : function(cmd,elm) {
        if (facePoseMap !== void) {
            var p;
            if ((p = facePoseMap[cmd]) !== void) {
                setPose(p,elm);
                setFace(cmd,elm);
            }
        } else {
            setFace(cmd,elm);
        }
    }incontextof this,
    pos     : this.setPosition incontextof this,
	emotion : function(param, elm) { this.setEmotion(param,elm); return 0;} incontextof this,
	hideemotion : this.hideEmotion incontextof this,
    xpos    : this.setXPos incontextof this,
    ypos    : this.setYPos incontextof this,
    front   : this.setFront incontextof this,
    back    : this.setBack incontextof this,
    level   : this.setLevel incontextof this,
    voice   : this.setVoice incontextof this,
    nextvoice : this.entryNextVoice incontextof this,
    clearvoice : this.clearVoice incontextof this,
    playvoice : this.playVoice2 incontextof this,
	stopvoice : this.stopVoice incontextof this,
    waitvoice : this.waitVoice incontextof this,
	facewin : function(param, elm) { disp = FACE; redraw = true; } incontextof this,
	faceon : null,
	faceoff : null,
	loop : null,
	bvoice : this.setBVoice incontextof this
        ];

	
	function setBVoice(param, elm) {
		var loop = elm.loop !== void ? +elm.loop : true;
		if (param == "" || loop || !kag.skipNoDisp) {
			backVoiceName = param;
			backVoiceLoop=loop;
			updateFlag = true;
		}
	}

	/**
     * ポーズ指定を優先処理する
     */
    function doPoseCommand(cmd, param, elm) {

        // ポーズコマンド
        if (cmd == "pose") {
            setPose(param, elm);
            return true;
        }

        // 顔ポーズマップが存在する場合
        if (facePoseMap !== void) {
            var p;
            if ((p = facePoseMap[cmd]) !== void) {
                setPose(p,elm);
                setFace(cmd,elm);
                return true;
            }
        }
        
        // ポーズ指定
        if (poses !== void) {
            if (poses[cmd] !== void) {
                setPose(cmd,elm);
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * コマンドの実行
     * @param cmd コマンド
     * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
    function doCommand(cmd, param, elm) {

        if (global.KAGEnvImage.doCommand(cmd, param, elm)) {
            return true;
        }

        var func;
        if ((func = charCommands[cmd]) !== void) {
            if (func != null) {
                func(param, elm);
            }
            return true;
        }
        
        var info;
        var find = false;

		if (!find && poses !== void && pose !== void && image === void) {
			var poseInfo;
			if ((poseInfo = poses[pose]) !== void) {
				var dresses       = poseInfo.dresses;
				var faces         = poseInfo.faces;
				if (dresses !== void && dresses[cmd] !== void) {
					//dm("服装を設定");
					find = true;
                    setDress(cmd,elm);
                } else if (faces !== void && faces[cmd] !== void) {
                    //dm("表情を設定");
                    find = true;
                    setFace(cmd,elm);
                }
            } else {
                dm("ポーズ情報がありません:" + pose + ":" + cmd);
            }
        }

		var posName = getTo(cmd);
        if (!find && env.positions !== void && env.positions[posName] !== void) {
            setPosition(cmd, elm);
            find = true;
        }            

        // アクション
        if (!find) {
            find = setAction(cmd, elm);
        }

        // エモーション
        if (!find) {
			find = setEmotion(cmd, elm);
        }
        
        // 更新
        if (!find) {
            find = setTrans(cmd, elm);
        }
        
        return find;
    };

	var imageFile;
	var timeInfo;

	function applyColor(layer) {
		if (timeInfo !== void) {
			with (layer) {
				// 環境光合成
				if (timeInfo.charLightColor !== void) {
					.holdAlpha = true;
					.fillOperateRect(0,0,
									 .imageWidth, .imageHeight,
									 timeInfo.charLightColor,
									 timeInfo.charLightType);
				}
				// 明度補正
				if (timeInfo.charBrightness !== void) {
					.light(timeInfo.charBrightness, timeInfo.charContrast);
				}
			}
		}
	}

	function getRedrawContext() {
		var context = global.KAGEnvImage.getRedrawContext();
		context.timeInfo = timeInfo;
		context.applyColor = applyColor;
		return context;
	}
	
	function layerRedrawFunction(layer) {
		applyColor(layer);
		global.KAGEnvImage.layerRedrawFunction(layer);
	}
	
    /**
     * 立ち絵の描画
     * @param layer 描画対象レイヤ
     * @param levelName レベル名
	 * @param _pose ポーズ指定
     * @oaram face 顔描画を示すフラグ
     * @return 成功したら true
     */
	function _drawLayerPose(layer, levelName, _pose) {

		var poseInfo;
		if (poses !== void && (poseInfo = poses[_pose]) !== void) {
			
			// 顔描画の場合は msgImage / msgFaceImage を優先
			var imageName     = (levelName == env.faceLevelName && poseInfo.msgImage !== void)     ? poseInfo.msgImage : poseInfo.image;
            var faceImageName = (levelName == env.faceLevelName && poseInfo.msgFaceImage !== void) ? poseInfo.msgFaceImage : poseInfo.faceImage;
            var dresses       = poseInfo.dresses;
            var faces         = poseInfo.faces;

            imageName = imageName.replace(/LEVEL/, levelName);

            // 服装指定が無い場合はデフォルトを参照
			var dressName;
			if (dress !== void) {
				dressName = dresses[dress];
            } 
			dressName = poseInfo.defaultDress if dressName === void;

            // 表情指定が無い場合はデフォルトを参照
            var faceName;
            if (face !== void) {
                faceName = faces[face];
            }
            faceName = poseInfo.defaultFace if faceName === void;

            //dm("dress:", dressName, "face:", faceName);
            
            if (faceImageName !== void) {
                
                // 顔分離型立ち絵

                // ベース部分
                imageFile = imageName.replace(/DRESS/, dressName);

                // ベース画像のロード
                if (baseImageName != imageFile) {
                    baseImageName = imageFile;
					// 画像ベースのキャッシュ用
					if (baseImage === void) {
						baseImage = new global.Layer(kag, kag.fore.base);
						baseImage.name = "立ち絵画像キャッシュ:" + name;
                    }
                    try {
                        baseImage.loadImages(imageFile);
                    } catch (e) {
                        if (dressName != poseInfo.defaultDress) {
                            // デフォルトの服装におとしこむ
                            dressName = poseInfo.defaultDress;
                            imageFile = imageName.replace(/DRESS/, dressName);
                            baseImageName = imageFile;
                            try {
                                baseImage.loadImages(imageFile);
                            } catch (e) {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    } 
                }
                
				// 画像をレイヤに割り当てる
				layer.assignImages(baseImage);
				// 初期化処理XXX ちょっと再検討必要かも
                layer.type    = layer._initType    = baseImage.type;
                layer.opacity = layer._initOpacity = baseImage.opacity;

                // レベル用調整処理
                faceImageName = faceImageName.replace(/LEVEL/, levelName);
                
                //　表情指定
                if (faceName !== void) {
                    imageFile = faceImageName.replace(/DRESS/, dressName);
                    imageFile = imageFile.replace(/FACE/, faceName);
                    var imageInfo;
                    if (faceImage === void) {
                        faceImage = new global.Layer(kag, kag.fore.base);
                        faceImage.name = "立ち絵顔画像処理用:" + name;
                    }
                    try {
                        imageInfo = faceImage.loadImages(imageFile);
                    } catch (e) {
                        var succeeded = false;
                        // 服装のデフォルトおとしこみはエラー扱いではない
                        if (dressName != poseInfo.defaultDress) {
                            dressName = poseInfo.defaultDress;
                            imageFile = faceImageName.replace(/DRESS/, dressName);
                            imageFile = imageFile.replace(/FACE/, faceName);
                            try {
                                imageInfo = faceImage.loadImages(imageFile);
                                succeeded = true;
                            } catch (e) {
                            }
                        }
                        if (!succeeded) {
                            if (faceName != poseInfo.defaultFace) {
                                // デフォルトの表情におとしこむ
                                faceName = poseInfo.defaultFace;
                                imageFile = faceImageName.replace(/DRESS/, dressName);
                                imageFile = imageFile.replace(/FACE/, faceName);
                                try {
                                    imageInfo = faceImage.loadImages(imageFile);
                                } catch (e) {
                                    return false;
                                }
                            } else {
                                return false;
                            }
                        }
                    }
					var operateMode = omPsNormal;
					if (imageInfo && imageInfo.offs_x !== void) {
						layer.operateRect(imageInfo.offs_x, imageInfo.offs_y,
										  faceImage, 0, 0, faceImage.imageWidth, faceImage.imageHeight, operateMode);
                    } else {
                        layer.operateRect(0,0,faceImage,0,0,faceImage.imageWidth, faceImage.imageHeight, operateMode);
                    }
				}
				return true;
                
            } else {
                // 顔合成型立ち絵
                // 服装情報で上書き
                if (dressName !== void) {
                    imageFile = imageName.replace(/DRESS/, dressName);
                } else {
                    imageFile = imageName;
                }
                // 表情で上書き
                if (faceName !== void) {
                    imageFile = imageFile.replace(/FACE/, faceName);
                }
                try {
					if (layer instanceof "AnimationLayer") {
						var elm = %[ storage:imageFile ];
						layer.loadImages(elm);
                    } else {
						layer.loadImages(imageFile);
                    }
                } catch (e) {
                    return false;
                }
                return true;
            }
        }
        return false;
    }

    /**
     * 現在の立ち絵の描画
     * @param layer 描画対象レイヤ
     * @param levelName レベル名
     */
    function _drawLayer(layer, levelName) {

        imageFile = "";
        if (image !== void) {
            var imageName = image.replace(/LEVEL/, levelName);
            try {
				if (layer instanceof "AnimationLayer") {
					var elm = %[ storage:image ];
					layer.loadImages(elm);
                } else {
					layer.loadImages(image);
				}
            } catch (e) {
				kag.errorImage(image+ ":立ち絵画像がロードできません name:" + name);
                return;
            }
		} else {
			if (!_drawLayerPose(layer, levelName, pose) &&
				!(pose != init.defaultPose && _drawLayerPose(layer, levelName, init.defaultPose))) {
				kag.errorImage(imageFile + ":立ち絵画像がロードできません name:" + name + " pose:" + pose + " dress:" + dress + " face:" + face);
				return;
			}
        }

		// サイズ補正
		layer.setSizeToImageSize();
    }

    /**
     * 現在の立ち絵の描画
     * @param layer 描画対象レイヤ
     */
	function drawLayer(layer) {
		if (emotionLayer !== void && emotionLayer.visible == false) {
			invalidate emotionLayer;
			emotionLayer = void;
		}
		if (isShowBU()) {
			var levelName;
			var levelInfo = env.levels[level];
			if (levelInfo !== void) {
				levelName = levelInfo.name;
			}
			if (levelName === void) {
				levelName = level;
			}
			_drawLayer(layer, levelName);

			// 未初期化時デフォルト
			if (xpos === void) {
				xpos = env.defaultXpos;
			}
			if (ypos === void) {
				ypos = env.defaultYpos;
			}
		}
	}

    /**
     * 表情を描画する
     */
    function drawFace(layer, faceLevelName) {
		//dm("表情描画:" + name + " face:" + face + " layer:" + layer.name + " level:" + faceLevelName);
		if (poses !== void) {
			_drawLayer(layer, faceLevelName);
			if (env.envinfo.faceApplyColor) {
				applyColor(layer);
			}
			layer.visible = true;
        } else {
            layer.visible = false;
        }
    }

	function emoConv(emo) {
		if (emo instanceof "Array") {
			//dm("エモーションレベル:" + level);
			return emo[level];
		}
		return emo;
	}

	/**
	 * 現在のエモーション用情報を取得
	 * @param name 名前指定
	 * emoX, emoY, emoRev を含む
	 */
	function getEmotionInfo(emotion) {
		
		// デフォルト
		var emoX   = emoConv(env.envinfo.emoX);
		var emoY   = emoConv(env.envinfo.emoY);
		var emoRev = 0;
		
		// キャラ別補正
		emoX = emoConv(init.emoX) if init.emoX !== void;
		emoY = emoConv(init.emoY) if init.emoY !== void;
		emoRev = init.emoRev if init.emoRev !== void;

		// ポーズ別補正
		if (poses !== void) {
			var p = poses[pose];
			if (p !== void) {
				emoX   = p.emoX if p.emoX !== void;
				emoY   = p.emoY if p.emoY !== void;
				emoRev = p.emoRev if p.emoRev !== void;
			}
		}

		// 配置指定で補正
		if (emotion) {
			return %[
			emoX: emoX + (emoRev ? -emotion.xoff:emotion.xoff),
			emoY: emoY + emotion.yoff,
			emoRev: emoRev
				];
		} else {
			return %[
			emoX: emoX,
			emoY: emoY,
			emoRev: emoRev
				];
		}
	}

	var emotionDone;
	
	function updateNoDisp() {
		if (redraw && emotionDone) {
			emotion = void;
		}
		emotionDone = emotion !== void;
	}
	
    /**
     * レイヤ状態更新処理
     * エモーション処理を追加
     */
	function updateLayer(layer) {
		global.KAGEnvImage.updateLayer(...);
		
		// エモーション消去処理
		if (hideemo !== void) {
			if (emotionLayer !== void && emotionLayer.visible) {
				if (!isSkip() && hideemo > 1) {
					emotionLayer.stopAction();
					emotionLayer.beginAction(%[visvalue:%[handler:"MoveAction", value:0, time:hideemo, hide:true]]);
				} else {
					emotionLayer.stopAction();
					emotionLayer.visible = false;
				}
			}
			hideemo = void;
		}
		
		// 新規エモーション処理
		if (emotion !== void) {
			if (isShowBU()) {
				var levelName;
				var levelInfo = env.levels[level];
				if (levelInfo !== void) {
					levelName = levelInfo.name;
				}
				if (levelName === void) {
					levelName = level;
				}

				// ポーズ別補正
				var info = getEmotionInfo(emotion);
				//dm("エモーション原点:" + info.emoX + "," + info.emoY + " rev:" + info.emoRev + " level:" + levelName);
				
				// 新規エモーションレイヤ
				if (emotionLayer === void) {
					emotionLayer = new EmotionLayer(kag, kag.fore.base, this);
					emotionLayer.name = name + "エモーション";
				}
				emotionLayer.stopAction();
				var emoOrigin = emotion.origin !== void ? emotion.origin : 9;
				var emoAction = emotion.action;
				if (info.emoRev && emotion.imageRev !== void) {
					var name = emotion.imageRev;
					name = name.replace(/LEVEL/, levelName);
					emotionLayer.loadImages(%[storage:name]);
					emoOrigin = emotion.originRev if emotion.originRev !== void;
					emoAction = emotion.actionRev if emotion.actionRev !== void;
				} else {
					var name = emotion.image;
					name = name.replace(/LEVEL/, levelName);
					emotionLayer.loadImages(%[storage:name]);
				}
				with (emotionLayer) {
					//dm("エモーションアクション:" + emoAction + ":" + emotion.time);
					.updateOffsetInfo();

					switch (emoOrigin) {
					case 1: .afx = "left";   .afy = "top"; break;
					case 2: .afx = "center"; .afy = "top"; break;
					case 3: .afx = "right"; .afy = "top"; break;
					case 4: .afx = "right"; .afy = "center"; break;
					case 5: .afx = "right"; .afy = "bottom"; break;
					case 6: .afx = "center"; .afy = "bottom"; break;
					case 7: .afx = "left"; .afy = "bottom"; break;
					case 8: .afx = "left"; .afy = "center"; break;
					case 9: .afx = "center"; .afy = "center"; break;
					default: .afx = .defaultAfx; .afy = .defaultAfy; break;
					}
					.originx = layer.originx;
					.originy = layer.originy;
					.setPos(layer.left + info.emoX, layer.top + info.emoY);
					if (emoAction !== void) {
						var action = createAction(emoAction, %[time:emotion.time]);
						if (action !== void) {
							//dm("エモーションアクション時刻:" + action.time);
							var target = (action instanceof "Array") ? action[action.count-1] : action;
							if (emotion.nowait !== void) {
								target.nowait = +emotion.nowait;
							} else if (target.nowait == void) {
								target.nowait = true;
							}
							target.hide = +emotion.hide if emotion.hide !== void;
							.beginAction(action);
						}
					}
					.parent   = layer.parent;
					.absolute = layer.absolute+1;
					.visvalue = 100;
				}
				//dm("emoLayer", layer.parent.name, layer.absolute);
			}
			invalidate emotion;
			emotion = void;
		}
    }

	/**
	 * 更新処理
	 */
	function _update() {
		timeInfo = env.currentTime;

		// 立ち絵系更新
		var ret = global.KAGEnvImage._update(...);

		// 表情更新
		if (redrawFace) {
			if (env.currentNameTarget != this) {
				env.drawName();
			}
			env.drawFacePage(kag.fore, this);
			env.currentNameTarget = this;
			redrawFace = false;
		}
		
		// ループボイス対応用
		if (doBackVoice) {
			if (backVoiceName === void || backVoiceName == "" || !openBackVoice(backVoiceName, backVoiceLoop)) {
				stopBackVoice();
				backVoiceName = void;
			} else {
				stopVoice();
				startBackVoice();
				if (!backVoiceLoop) {
					backVoiceName = void;
				}
			}
			doBackVoice = false;
		}
		return ret;
	}

	/**
	 * KAG タグ処理
	 * @param elm コマンドパラメータ
	 */
	function command(elm) {
		var e = %[];
		(Dictionary.assign incontextof e)(elm); 
		var names = [];
		names.assign(e);
		// ポーズ指定コマンドを優先処理する
		for (var i=0; i<names.count; i+= 2) {
			if (doPoseCommand(names[i], names[i+1], e)) {
				delete e[names[i]];
			}
		}
		global.KAGEnvImage.command(e);
	}
	
	// ----------------------------------------------------------
	// ボイス処理
	// ----------------------------------------------------------

	var reNumber = new RegExp("^[0-9][0-9]*$");
	var cutZero  = new RegExp("^0*", "g"); // 先頭の0の文字カット用（残すと８進数とみなされるので）

    // 加算しないフラグ
    var noinc;
    
    /**
     * ボイスファイルの指定
     */
    function setVoice(param, elm) {
		// ボイスなし指定
		if (init.noVoice !== void) {
			return;
		}
		if (typeof param == "Integer") {
			if (elm !== void && elm.once) {
				strVoice = getVoice(param);
			} else {
				voice = param;
				strVoice = void;
			}
		} else if (typeof param == "String") {
			if (reNumber.test(param)) {
				param = (int)(cutZero.replace(param, ""));
				if (elm !== void && elm.once) {
					strVoice = getVoice(param);
				} else {
					voice = param;
					strVoice = void;
                }
            } else if (param.charAt(0) == "@") {
				voice += +param.substr(1);
            } else {
                strVoice = param;
            }
        } else {
            voice = void;
            strVoice = void;
        }
		incVoice   = elm !== void ? elm.incvoice : false;
		noincVoice = elm !== void ? elm.noincvoice : false;
        //dm("ボイス設定:" + param + ":" + voice);
    }

    /**
     * ボイスファイル指定＋次回再生エントリ
     */
	function entryNextVoice() {
		var voicename = strVoice == "ignore" ? void : getVoice(strVoice !== void ? strVoice : voice);
		if (strVoice === void || incVoice) {
			if (typeof voice == "Integer") {
				if (!noincVoice) {
					voice++;
				}
			} else {
				voice = void;
			}
		}
		incVoice   = void;
		noincVoice = void;
		strVoice   = void;

		if (voicename !== void) {
			env.entryNextVoice(name, voicename);
			kag.sflags["voice_" + init.voiceName] = true if (init.voiceFlag);
		}
    }
    
    /**
     * ボイスファイル指定の解除
     */
    function clearVoice() {
        voice = void;
        strVoice = void;
    }
    
    /**
     * ボイスファイル名の取得
     * @param voice パラメータ　数値の場合は書式処理、文字列の場合はそのまま返す
     */
    function getVoice(voice) {
        if (typeof voice == "Integer") {
            if (init.voiceFile === void) {
                return void;
            }
            var voiceBase = kag.flags.voiceBase !== void ? kag.flags.voiceBase : "";
            // 名前指定がある場合でデフォルト名でない場合は Nつきのファイル名で参照する
            if (kag.flags.name !== void && (kag.flags.name != kag.defaultName || kag.flags.family != kag.defaultFamily)) {
                var name = init.voiceFile.sprintf(voiceBase, voice, "N");
                if (Storages.isExistentStorage(name)) {
                    return name;
                }
            }
            // 普通の名前の場合
            return init.voiceFile.sprintf(voiceBase, voice, "");
        } else if (typeof voice == "String") {
            return voice;
        }
        return void;
    }

	function showVoiceInfo() {
		dm("[" + name + " voice=" + voice + "]");
	}
	
	var initSound;
	var soundBuffer; // ボイス用サウンドバッファ
    var voiceEndTime;

	var backVoiceBuffer; //< ループボイス用サウンドバッファ
	var _backVoiceName; //< ループボイスファイル名
	var doBackVoice = false; //< ループボイス開始用フラグ
	var backVoiceLoop = false;

	property backVoiceName {
		getter() {
			return _backVoiceName;
		}
		setter(v) {
			_backVoiceName = v;
			doBackVoice = true;
		}
	}
	
    function updateVoice() {
        initSound = true;
    }
    
    /**
     * ボイス開始時処理
     */
    function onStartVoice() {
		//dm("ボイス開始ボリューム制御開始");
        if (kag.bgmdown && !kag.skipMode) {
            kag.bgm.voldown = true;
		}
		if (backVoiceName !== void) {
			stopBackVoice();
		}
    }

    /**
     * ボイス停止時処理
     */
    function onStopVoice() {
		//dm("ボイス開始ボリューム制御完了");
		voiceEndTime = void;
		if (kag.bgm.voldown) {
			kag.bgm.voldown = false;
        }
		if (backVoiceName !== void) {
			if (!doBackVoice) {
				startBackVoice();
			}
		}
    }

	function getVoicename(voicename) {
		// 拡張子補完処理
		kag.errorLine(void, name + ":ボイス再生:" + voicename);
		if (!Storages.isExistentStorage(voicename)) {
			var test;
			if (test = voicename + ".wav", Storages.isExistentStorage(test)) {
				return test;
			} else if(test = voicename + ".ogg", Storages.isExistentStorage(test)) {
				return test;
			} else {
				kag.errorVoice(name + ":ボイスがロードできません:" + voicename);
				return void;
			}
		}
		return voicename;
	}

    /**
     * ボイスの再生
     */
    function playVoice(voicename=void) {
		voiceEndTime = void;
		var ret = void;
		
		if (!kag.skipNoDisp && voicename !== void && voicename != ""){
			//dm("再生処理:" + voicename);
			voicename = getVoicename(voicename);
			if (voicename !== void && kag.getVoiceOn(init.voiceName) && !kag.skipMode && kag.voiceenable) {
				if (initSound) {
                    if (soundBuffer !== void) {
                        invalidate soundBuffer;
                        soundBuffer = void;
                    }
                    initSound = false;
                }
                if (soundBuffer === void) {
                    soundBuffer = new VoiceTrack(this, kag);
                }
				resetVoiceVolume();
				try {
                    if (kag.voicespeed != 1.0 && typeof soundBuffer.filters != "undefined") {
                        soundBuffer.filters.clear();
                        soundBuffer.filters.add(new WaveSoundBuffer.PhaseVocoder());
                        soundBuffer.filters[0].window = 256;
                        soundBuffer.filters[0].time = 1.0 / kag.voicespeed;
						soundBuffer.open(voicename);
                        soundBuffer.play();
                        ret = (int)(soundBuffer.totalTime / kag.voicespeed);
                    } else {
                        soundBuffer.open(voicename);
                        soundBuffer.play();
                        ret = soundBuffer.totalTime;
                    }
                } catch (e) {
                }
			}
		}
		if (ret) {
            voiceEndTime = System.getTickCount() + ret;
		} else {
			kag.extractDelay("*");
			onStopVoice();
		}
        return ret;
    }

    /**
     * ボイスの外部からの再生
     */
    function playVoice2(param) {
        //dm("外部ボイス再生:" + param);
        if (typeof param == "String") {
            if (reNumber.test(param)) {
                param = (int)(cutZero.replace(param, ""));
            }
		} else {
			param = void;
		}
		playVoice(getVoice(param));
    }

    /**
     * ボイスの停止
     */
    function stopVoice() {
        voiceEndTime = void;
        if (soundBuffer !== void) {
            soundBuffer.stop();
            if (typeof soundBuffer.filters != "undefined") {
                soundBuffer.filters.clear();
            }
        }
    }

    /**
     * ボイス待ち
     * @param true の場合スキップ可能（デフォルト）
     * @param falseの場合スキップ不可能
     */
    function waitVoice(param) {
		if (voiceEndTime !== void) {
			var waitTime = voiceEndTime - System.getTickCount();
			ret = kag.waitTime(waitTime, +param && kag.clickSkipEnabled);
		}
    }
    
    /**
     * ボイスのボリュームの再調整
     */
    function resetVoiceVolume() {
		if (soundBuffer !== void) {
			var per = init.voiceVolume;
			var vol = kag.getVoiceVolume(init.voiceName);
			soundBuffer.volume2 = ((per !== void) ? (vol * +per / 100) : vol) * 1000;
        }
	}

	/**
	 * ループボイスのファイルを開く
	 */
	function openBackVoice(voicename, loop) {
		if (voicename !== void && voicename != ""){
			voicename = getVoicename(voicename);
			if (voicename !== void && kag.getVoiceOn(init.voiceName) && (loop ? kag.bgvenable : kag.voiceenable)) {
				if (backVoiceBuffer === void) {
					backVoiceBuffer = new BackVoiceTrack(this, kag);
				}
				resetBackVoiceVolume();
				backVoiceBuffer.open(voicename);
				backVoiceBuffer.looping = loop;
				return true;
			}
		}
		return false;
	}

    /**
	 * ループボイスのボリュームの再調整
     */
	function resetBackVoiceVolume() {
		if (backVoiceBuffer !== void) {
			var per = init.voiceVolume;
			var vol = kag.getBGVVolume(init.voiceName);
			backVoiceBuffer.volume2 = ((per !== void) ? (vol * +per / 100) : vol) * 1000;
        }
	}

	/**
	 * ループボイス開始
	 */
	function startBackVoice() {
		//dm("バックボイス再開");
		if (backVoiceBuffer !== void) {
			backVoiceBuffer.stopFade();
			if (backVoiceBuffer.status != "play") {
				backVoiceBuffer.volume = 0;
				backVoiceBuffer.play();
			}
			backVoiceBuffer.fade(100000,300);
		}
	}

	/**
	 * ループボイス終了
	 */
	function stopBackVoice() {
		if (backVoiceBuffer !== void) {
			backVoiceBuffer.fade(0,300);
		}
	}

	// -----------------------------------------------------------------
	// 立ち絵情報参照用
	// -----------------------------------------------------------------

	// ポーズ名前一覧取得
	function getPoseNames() {
		var ret = [];
		var names = [];
		names.assign(poses);
		for (var i=0;i<names.count;i+=2) {
			ret.add(names[i]);
		}
		ret.sort();
		return ret;
	}
	
	// 服装名前一覧取得
	function getDressNames() {
		var ret = [];
		var info = poses[pose];
		if (info !== void && info.dresses !== void) {
			var names = [];
			names.assign(info.dresses);
			for (var i=0;i<names.count;i+=2) {
				ret.add(names[i]);
			}
		}
		ret.sort();
		return ret;
	}

	// 表情名前一覧取得
	function getFaceNames() {
		var ret = [];
		var info = poses[pose];
		if (info !== void && info.faces !== void) {
			var names = [];
			names.assign(info.faces);
			for (var i=0;i<names.count;i+=2) {
				ret.add(names[i]);
			}
		}
		ret.sort();
		return ret;
	}
};
