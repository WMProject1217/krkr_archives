Scripts.execStorage("utils.tjs");

class Biscrat_Compiler
{
	const settingFileName = "compile_setting.tjs";
	const includeFilePath = "include/preprocessSetting.tjs";
	const preprocessCommand = "C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin\\cl.exe";
	const preprocessParamDebug = "/E /X \"{SRC}\" /EP /P /Fi\"{DEST}\" /D__DEBUG=1 /D__RELEASE=0 /FI\"{INCLUDE}\"";
	const preprocessParamRelease = "/E /X \"{SRC}\" /EP /P /Fi\"{MID}\" /D__DEBUG=0 /D__RELEASE=1 /FI\"{INCLUDE}\"";
	
	var settings;
	var compiledFiles = %[];
	
	function Biscrat_Compiler() {}
	
	function error(message) {
		throw new Exception(message);
	}
	
	function reset() {
		settings = Scripts.evalStorage(settingFileName);
		(Dictionary.clear incontextof compiledFiles)();
	}
	
	function checkExtension(map, file) {
		var type = map[Storages.extractStorageExt(file)];
		if (type === void) {
			error(@"異常な拡張子です(${file})");
			return;
		}
		return type;
	}
	
	function preprocess(param, dest, srcModifiedTime) {
		dm(@"PREPROCEE: ${preprocessCommand} ${param}\n");
		var result = System.commandExecute(preprocessCommand, param);
		switch (true) {
		case result.status !== "ok":
			error("プリプロセスに失敗しました。\n" + result.message + "\n" + dest);
			break;
		case result.exitcode !== 0:
			dm(@"ERROR : exitcode = ${result.exitcode}\n");
			foreach(result.stdout, function(idx, value) {
				dm(value + "\n");
			});
			Storages.deleteFile(dest);
			error("プリプロセスに失敗しました。\n" + dest);
			break;
		default:
			if (!Storages.setLastModifiedFileTime(dest, srcModifiedTime)) {
				error(@"タイムスタンプの設定に失敗しました。(${dest})");
			}
			break;
		}
	}
	
	function compileDirectoryDebug(src, dest) {
		createDirectoryIfNotExist(dest);
		reset();
		foreachFilesInDirectory(src, dest, function(src, filename, dest) {
			if (!checkExtension(settings.extensions_debug, src)) return;
			var srcModifiedTime = Storages.getLastModifiedFileTime(src);
			if (!Storages.isExistentStorage(dest) || Storages.getLastModifiedFileTime(dest) !== srcModifiedTime) {
				var param = expandMessageStrings(preprocessParamDebug, "SRC", Storages.getLocalName(src), "DEST", Storages.getLocalName(dest), "INCLUDE", Storages.getLocalName(includeFilePath));
				preprocess(param, dest, srcModifiedTime);
			}
		});
	}
	
	function compileDirectoryRelease(src, dest, mid) {
		createDirectoryIfNotExist(dest);
		createDirectoryIfNotExist(mid);
		reset();
		foreachFilesInDirectory(src, dest, function(src, filename, dest, mid) {
			if (!checkExtension(settings.extensions_release, src)) return;
			var srcModifiedTime = Storages.getLastModifiedFileTime(src);
			if (!Storages.isExistentStorage(dest) || Storages.getLastModifiedFileTime(dest) !== srcModifiedTime) {
				var param = expandMessageStrings(preprocessParamRelease, "SRC", Storages.getLocalName(src), "MID", Storages.getLocalName(mid), "INCLUDE", Storages.getLocalName(includeFilePath));
				preprocess(param, mid, srcModifiedTime);
			}
		}, mid);
		
		foreach(compiledFiles, function(filename, value, dest, mid) {
			dest += filename;
			mid += filename;
			if (Storages.getLastModifiedFileTime(dest) == Storages.getLastModifiedFileTime(mid)) { return; }
			dm(@"COMPILE : ${mid} => ${dest}");
			if (settings.dataFiles[filename]) {
				var data = Scripts.evalStorage(Storages.getfullPath(mid));
				if (data instanceof "Dictionary") {
					(Dictionary.saveStruct incontextof data)(dest, "b");
				} else if (data instanceof "Array") {
					data.saveStruct(dest, "b");
				} else {
					error(@"不正なデータファイルです。${filename}");
				}
			} else {
				Scripts.compileStorage(mid, dest);
			}
			if (!Storages.setLastModifiedFileTime(dest, Storages.getLastModifiedFileTime(mid))) {
				error(@"タイムスタンプの設定に失敗しました。(${dest})");
			}
		}, dest, mid);
	}
	
	function foreachFilesInDirectory(src, dest, func, mid) {
		foreach(getFilesInDirectory(src), function(idx, src, dest, func, mid) {
			var filename = Storages.extractStorageName(src).toLowerCase();
			if (settings.ignoreFiles[filename]) { return; }
			if (compiledFiles[filename]) {
				error("ファイル名が重複しています。");
				return;
			}
			compiledFiles[filename] = true;
			func(src, filename, dest + filename, mid + filename);
		}, dest, func, mid);
	}
}


const basePath = System.exePath;
const srcPath = basePath + "src/";
const debugPath = basePath + "data/debug/";
const releasePath = basePath + "data/release/";
const releaseIntermediatePath =  basePath + "data/release_intermediate/";

var compiler = new Biscrat_Compiler();
var deleteFilesCallback = function(idx, path) {
	if (Storages.extractStorageName(path) == ".gitkeep") return;
	Storages.deleteFile(path);
};
if (System.getArgument("-compiledebug") == "yes") {
	if (System.getArgument("-clean") == "yes") {
		foreach(getFilesInDirectory(debugPath), deleteFilesCallback);
	}
	compiler.compileDirectoryDebug(srcPath, debugPath);
}

if (System.getArgument("-compilerelease") == "yes") {
	if (System.getArgument("-clean") == "yes") {
		foreach(getFilesInDirectory(releasePath), deleteFilesCallback);
	}
	compiler.compileDirectoryRelease(srcPath, releasePath, releaseIntermediatePath);
}
